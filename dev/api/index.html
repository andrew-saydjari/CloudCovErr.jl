<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CloudCovErr.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="CloudCovErr.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CloudCovErr.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Covariance-Construction-Functions"><span>Covariance Construction Functions</span></a></li><li><a class="tocitem" href="#Per-Star-Functions"><span>Per Star Functions</span></a></li><li><a class="tocitem" href="#Image-Infill-and-Masking"><span>Image Infill and Masking</span></a></li><li><a class="tocitem" href="#DECam-Specific-Functions"><span>DECam Specific Functions</span></a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Covariance-Construction-Functions"><a class="docs-heading-anchor" href="#Covariance-Construction-Functions">Covariance Construction Functions</a><a id="Covariance-Construction-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Construction-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.cov_avg!" href="#CloudCovErr.cov_avg!"><code>CloudCovErr.cov_avg!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cov_avg!(bimage, ism, bism, in_image; Np::Int=33, widx::Int=129, widy::Int=129, ftype::Int=32)</code></pre><p>Key function for constructing the (shifted and multiplied) versions of the input image used to quickly estimate the local covariance matrix at a large number of locations. The main output is in the preallocated <code>bism</code> which is used as an input to <code>build_cov!</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>bimage</code>: preallocated output array for the boxcar smoothed unshifted image</li><li><code>ism</code>: preallocated intermediate array for the input image times itself shifted</li><li><code>bism</code>: preallocated output array to store boxcar-smoothed image products for all shifts</li><li><code>in_image</code>: input image the local covariance of which we want to estimate</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np::Int</code>: size of local covariance matrix in pixels (default 33)</li><li><code>widx::Int</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>widy::Int</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/cov.jl#L79-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.boxsmooth!" href="#CloudCovErr.boxsmooth!"><code>CloudCovErr.boxsmooth!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxsmooth!(out::AbstractArray, arr::AbstractArray, tot::Array{T,1}, widx::Int, widy::Int)</code></pre><p>Boxcar smooths an input image (or paddedview) <code>arr</code> with window size <code>widx</code> by <code>widy</code>. We pass the original image size <code>sx</code> and <code>sy</code> to help handle image views.</p><p><strong>Arguments:</strong></p><ul><li><code>out::AbstractArray</code>: preallocated output array for the boxcar smoothed image</li><li><code>arr::AbstractArray</code>: input array for which boxcar smoothing is computed (generally paddedview)</li><li><code>tot::Array{T,1}</code>: preallocated array to hold moving sums along 1 dimension</li><li><code>widx::Int</code>: size of boxcar smoothing window in x</li><li><code>widy::Int</code>: size of boxcar smoothing window in y</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/cov.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.outest_bounds" href="#CloudCovErr.outest_bounds"><code>CloudCovErr.outest_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outest_bounds(cx,sx) -&gt; px0</code></pre><p>Helper function to find maximum padding in pixels required to accomodate all query points <code>cx</code> outside of the image size 1:<code>sx</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>cx</code>: list of integer star centers (in either x or y)</li><li><code>sx</code>: image dimension along the axis indexed by <code>cx</code></li></ul><p><strong>Outputs:</strong></p><ul><li><code>px0</code>: maximum padding in pixels required to accomodate all query points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/cov.jl#L10-L21">source</a></section></article><h2 id="Per-Star-Functions"><a class="docs-heading-anchor" href="#Per-Star-Functions">Per Star Functions</a><a id="Per-Star-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Per-Star-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.stamp_cutter" href="#CloudCovErr.stamp_cutter"><code>CloudCovErr.stamp_cutter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stamp_cutter(cx,cy,residimIn,star_im,maskim;Np=33) -&gt; data_in, stars_in, kmasked2d</code></pre><p>Cuts out local stamps around each star of the various input images to be used for per star statistics calculations.</p><p><strong>Arguments:</strong></p><ul><li><code>cx</code>: center coorindate x of the stamp</li><li><code>cy</code>: center coorindate y of the stamp</li><li><code>residimIn</code>: residual image with infilling from which covariance was estimated</li><li><code>star_im</code>: input image of model of stars only. abs(mod<em>im-sky</em>im)</li><li><code>maskim</code>: input image of upstream masked pixels</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: size of covariance matrix footprint around each star (default 33)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>data_in</code>: local stamp of the (non-infilled) residual image</li><li><code>stars_in</code>: local stamp of model of stars only</li><li><code>kmasked2d</code>: local stamp of upstream masked pixels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/perstar.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.gen_pix_mask" href="#CloudCovErr.gen_pix_mask"><code>CloudCovErr.gen_pix_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_pix_mask(kmasked2d,psfmodel,circmask,x_star,y_star,flux_star;Np=33,thr=20) -&gt; psft, kstar, kpsf2d, kcond0, kcond, kpred, dnt</code></pre><p>Assigns pixels in the local subimage around a star to either be &quot;good&quot;, &quot;hidden&quot;, or &quot;ignored&quot; based on user settings and the flux of the star. Reads in masked pixels from the quality flags on pixels coming from the community pipeline <code>kmasked2d</code>, a PSF model for the star, and a precomputed circular mask <code>circmask</code> to exclude pixels at a large radius from the stellar center since they have little impact on the regression of hidden pixels. The pixels assigned as &quot;hidden&quot; and to be interpolated are determined by a <code>thr</code> on the pixel values for <code>flux_star</code> times the PSF model. We use a parametric PSFs that varies with position and query the PSF at the stellar position for each star.</p><p><strong>Arguments:</strong></p><ul><li><code>kmasked2d</code>: Bool mask from upstream pixel quality flags to assign pixels as &quot;ignored&quot;</li><li><code>psfmodel</code>: parametric PSF model that can be queried at different positions</li><li><code>circmask</code>: static Bool mask assigning pixels beyond some radius of the stellar center as &quot;ignored&quot;</li><li><code>x_star</code>: x-coordinate of the star (used only for flexible PSF model query)</li><li><code>y_star</code>: y-coordinate of the star (used only for flexible PSF model query)</li><li><code>flux_star</code>: flux of star in ADU to determine how large a region to make &quot;hidden&quot;</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: size of local covariance matrix in pixels (default 33)</li><li><code>thr</code>: threshold for psf-based masking of the residuals (larger more &quot;hidden&quot;)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>psft</code>: static array (image) of the stellar PSF</li><li><code>kstar</code>: Boolean indexes the NOT &quot;good&quot; pixels</li><li><code>kpsf2d</code>: Boolean indexes the &quot;hidden&quot; pixels</li><li><code>kcond0</code>: initial number of &quot;good&quot; pixels</li><li><code>kcond</code>: final number of &quot;good&quot; pixels after fallbacks</li><li><code>kpred</code>: the number of pixels &quot;hidden&quot;</li><li><code>dnt</code>: quality flag bits on the solution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/perstar.jl#L39-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.condCovEst_wdiag" href="#CloudCovErr.condCovEst_wdiag"><code>CloudCovErr.condCovEst_wdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">condCovEst_wdiag(cov_loc,μ,km,kpsf2d,data_in,stars_in,psft;Np=33,export_mean=false,n_draw=0,diag_on=true) -&gt; out</code></pre><p>Using a local covariance matrix estimate <code>cov_loc</code> and a set of known (&quot;good&quot;) pixels <code>km</code> and &quot;hidden&quot; pixels <code>kpsf2d</code>, this function computes a prediction for the mean value of the <code>kpsf2d</code> pixels and the covariance matrix of the <code>kpsf2d</code> pixels. In terms of statistics use to adjust the photometry of a star, we are only interested in the pixels masked as a result of the star (i.e. not a detector defect or cosmic ray nearby). The residual image <code>data_in</code> and a model of the counts above the background coming from the star <code>stars_in</code> for the local patch are also inputs of the function. Correction factors for the photometric flux and flux uncertainities are outputs as well as a chi2 value for the &quot;good&quot; pixels. The output list can conditionally include the mean reconstruction and draws from the distribution of reconstructions.</p><p><strong>Arguments:</strong></p><ul><li><code>cov_loc</code>: local covariance matrix</li><li><code>μ</code>: vector containing mean value for each pixel in the patch</li><li><code>km</code>: unmasked pixels</li><li><code>kpsf2d</code>: pixels masked due to the star of interest</li><li><code>data_in</code>: (non-infilled) residual image in local patch</li><li><code>psft</code>: static array (image) of the stellar PSF</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: size of local covariance matrix in pixels (default 33)</li><li><code>export_mean</code>: when true, returns the mean conditional prediction for the &quot;hidden&quot; pixels (default false)</li><li><code>n_draw</code>: when nonzero, returns that number of realizations of the conditional infilling (default 0)</li><li><code>diag_on</code>: flag for adding to the pixelwise uncertainty based on the photoelectron counts of the modeled star (default true)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>out[1][1]</code>: flux uncertainity of the star</li><li><code>out[1][2]</code>: flux uncertainity of the star assuming the covariance matrix were diagonal</li><li><code>out[1][3]</code>: flux correction which must be added to correct the input flux estimate</li><li><code>out[1][4]</code>: flux correction coming from the residuals (fdb_res)</li><li><code>out[1][5]</code>: flux correction coming from the predicted background (fdb_pred)</li><li><code>out[1][6]</code>: chi2 for the &quot;good&quot; pixels under <code>cov_loc</code> as a metric on how good our assumptions are</li><li><code>out[2]</code>: local region (image) with &quot;hidden&quot; pixels replaced by the mean conditional estimate (optional output)</li><li><code>out[end]</code>: local region (image) with &quot;hidden&quot; pixels replaced by the draws from the conditional distribution (optional output). Array is flattened to npix x n_draw.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/perstar.jl#L124-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.build_cov!" href="#CloudCovErr.build_cov!"><code>CloudCovErr.build_cov!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_cov!(cov::Array{T,2},μ::Array{T,1},cx::Int,cy::Int,bimage::Array{T,2},bism::Array{T,4},Np::Int,widx::Int,widy::Int) where T &lt;:Union{Float32,Float64}</code></pre><p>Constructs the local covariance matrix and mean for an image patch of size <code>Np</code> x <code>Np</code> pixels around a location of interest (<code>cx</code>,<code>cy</code>). The construction is just a lookup of pixel values from the stored boxcar-smoothed copies of the input image times itself shifted in <code>bism</code>. Passing the smoothed image <code>bimage</code> and the widths of the boxcar mean <code>widx</code> and <code>widy</code> is helpful for the mean and normalization. The covariance and mean are updated in place for speed since this operation may be performed billions of times since we construct a new covariance matrix for every detection. Math may either be performed <code>Float32</code> or <code>Float64</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>cov::Array{T,2}</code>: preallocated output array for local covariance matrix</li><li><code>μ::Array{T,1}</code>: preallocated output vector for local mean</li><li><code>cx::Int</code>: x-coordinate of the center of the local region</li><li><code>cy::Int</code>: y-coordinate of the center of the local region</li><li><code>bimage::Array{T,2}</code>: boxcar smoothed unshifted image</li><li><code>bism::Array{T,4}</code>: boxcar-smoothed image products for all shifts</li><li><code>Np::Int</code>: size of local covariance matrix in pixels</li><li><code>widx::Int</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate</li><li><code>widy::Int</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/perstar.jl#L221-L241">source</a></section></article><h2 id="Image-Infill-and-Masking"><a class="docs-heading-anchor" href="#Image-Infill-and-Masking">Image Infill and Masking</a><a id="Image-Infill-and-Masking-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Infill-and-Masking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.prelim_infill!" href="#CloudCovErr.prelim_infill!"><code>CloudCovErr.prelim_infill!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prelim_infill!(testim,bmaskim,bimage,bimageI,testim2,bmaskim2,goodpix,ccd;widx=19,widy=19,ftype::Int=32,widmult=1.4)</code></pre><p>This intial infill replaces masked pixels with a guess based on a smoothed boxcar. For large masked regions, the smoothing scale is increased. If this iteration takes too long/requires too strong of masking, the masked pixels are replaced with the median of the image.</p><p>We use 3 copies of the input image and mask image. The first is a view (with reflective boundary condition padding) with the pixels to be infilled replaced with zeros, the second is allocated to hold various smoothings of the image, and the third holds the output image which contains our best infill guess. A final Bool array of size corresponding to the image is used to keep track of pixels that have safe infill values.</p><p><strong>Arguments:</strong></p><ul><li><code>testim</code>: input image which requires infilling</li><li><code>bmaskim</code>: input mask indicating which pixels require infilling</li><li><code>bimage</code>: preallocated array for smoothed version of input image</li><li><code>bimageI</code>: preallocated array for smoothed mask counting the samples for each estimate</li><li><code>testim2</code>: inplace modified ouptut array for infilled version of image input</li><li><code>bmaskim2</code>: inplace modified mask to keep track of which pixels still need infilling</li><li><code>goodpix</code>: preallocated array for Bool indexing pixels with good infill</li><li><code>ccd</code>: string name of FITS extension for verbose cmdline printing</li></ul><p><strong>Keywords:</strong></p><ul><li><code>widx</code>: initial size of boxcar smoothing window in x (default 19)</li><li><code>widy</code>: initial size of boxcar smoothing window in y (default 19)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li><li><code>widmult</code>: multiplicative factor for increasing the smoothing scale at each iteration step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L209-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.gen_mask_staticPSF!" href="#CloudCovErr.gen_mask_staticPSF!"><code>CloudCovErr.gen_mask_staticPSF!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_mask_staticPSF!(maskd, psfstamp, x_stars, y_stars, flux_stars, thr=20)</code></pre><p>Generate a mask for an input image (which is usually an image of model residuals) that excludes the cores of stars (which are often mismodeled). In this function, we use a fixed PSF <code>psfstamp</code> for all sources, and adjust the masking fraction based on the stellar flux and a threshold <code>thr</code>. A more general position dependent PSF model could be used with a slight generalization of this function, but is likely overkill for the problem of making a mask.</p><p><strong>Arguments:</strong></p><ul><li><code>maskd</code>: bool image to which mask will be added (bitwise or)</li><li><code>psfstamp</code>: simple 2D array of a single PSF to be used for the whole image</li><li><code>x_stars</code>: list of source x positions</li><li><code>y_stars</code>: list of source y positions</li><li><code>flux_stars</code>: list of source fluxes</li></ul><p><strong>Keywords:</strong></p><ul><li><code>thr</code>: threshold used for flux-dependent masking (default 20)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L118-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.gen_mask_staticPSF2!" href="#CloudCovErr.gen_mask_staticPSF2!"><code>CloudCovErr.gen_mask_staticPSF2!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_mask_staticPSF2!(maskd, psfstamp, psfstamp1, x_stars, y_stars, flux_stars, thr=20)</code></pre><p>Generate a mask for an input image (which is usually an image of model residuals) that excludes the cores of stars (which are often mismodeled). In this function, we use a small fixed PSF <code>psfstamp1</code> for all faint sources, and adjust the masking fraction based on the stellar flux and a threshold <code>thr</code>. Only for source bright enough to need a larger PSF stamp do we use <code>psfstamp</code>, which saves some computational cost.</p><p><strong>Arguments:</strong></p><ul><li><code>maskd</code>: bool image to which mask will be added (bitwise or)</li><li><code>psfstamp</code>: simple 2D array of a single PSF to be used for bright stars in the whole image</li><li><code>psfstamp1</code>: simple 2D array of a single PSF to be used for faint stars in the whole image</li><li><code>x_stars</code>: list of source x positions</li><li><code>y_stars</code>: list of source y positions</li><li><code>flux_stars</code>: list of source fluxes</li></ul><p><strong>Keywords:</strong></p><ul><li><code>thr</code>: threshold used for flux-dependent masking (default 20)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L154-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.im_subrng" href="#CloudCovErr.im_subrng"><code>CloudCovErr.im_subrng</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">im_subrng(jx,jy,cx,cy,sx,sy,px0,py0,stepx,stepy,padx,pady,tilex,tiley) -&gt; xrng, yrng, star_ind</code></pre><p>Computes the flux a star must have so that the PSF-based masking using <code>thr</code> would require a larger stamp area. Used for computational savings.</p><p><strong>Arguments:</strong></p><ul><li><code>jx</code>: tile index along x</li><li><code>jy</code>: tile index along y</li><li><code>cx</code>: list of stellar x-coordinates</li><li><code>cy</code>: list of stellar y-coordinates</li><li><code>sx</code>: size of original image in x</li><li><code>sy</code>: size of original image in y</li><li><code>px0</code>: maximal padding in x to account for stars outside image</li><li><code>py0</code>: maximal padding in y to account for stars outside image</li><li><code>stepx</code>: tiling step size in x</li><li><code>stepy</code>: tiling step size in y</li><li><code>padx</code>: tile padding in x required to account for local stamp size, sample size, and pixels outside the image</li><li><code>pady</code>: tile padding in x required to account for local stamp size, sample size, and pixels outside the image</li><li><code>tilex</code>: total number of tile divisions along x</li><li><code>tiley</code>: total number of tile divisions along y</li></ul><p><strong>Outputs:</strong></p><ul><li><code>xrng</code>: slicing range of the tile in x</li><li><code>yrng</code>: slicing range of the tile in y</li><li><code>star_ind</code>: Bool mask of all stars falling within the tile (subimage)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L58-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.add_sky_noise!" href="#CloudCovErr.add_sky_noise!"><code>CloudCovErr.add_sky_noise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_sky_noise!(testim2,maskim,skyim,gain;seed=2021)</code></pre><p>Adds noise to the infill that matches the Poisson noise of a rough estimate for the sky background. A random seed to set a local random generator is provided for reproducible unit testing.</p><p><strong>Arguments:</strong></p><ul><li><code>testim2</code>: input image which had infilling</li><li><code>maskim</code>: mask of pixels which were infilled</li><li><code>skyim</code>: rough estimate of sky background counts</li><li><code>gain</code>: gain of detector to convert from photon count noise to detector noise</li></ul><p><strong>Keywords:</strong></p><ul><li><code>seed</code>: random seed for random generator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L302-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.add_noise!" href="#CloudCovErr.add_noise!"><code>CloudCovErr.add_noise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_noise!(testim2,gain;seed=2021)</code></pre><p>Adds noise to an image that matches the Poisson noise of the pixel counts. A random seed to set a local random generator is provided for reproducible unit testing.</p><p><strong>Arguments:</strong></p><ul><li><code>testim2</code>: input image which had infilling</li><li><code>gain</code>: gain of detector to convert from photon count noise to detector noise</li></ul><p><strong>Keywords:</strong></p><ul><li><code>seed</code>: random seed for random generator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L328-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.findmaxpsf" href="#CloudCovErr.findmaxpsf"><code>CloudCovErr.findmaxpsf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmaxpsf(psfstamp1;thr=20) -&gt; flim</code></pre><p>Computes the flux a star must have so that the PSF-based masking using <code>thr</code> would require a larger stamp area. Used for computational savings.</p><p><strong>Arguments:</strong></p><ul><li><code>psfstamp1</code>: a small image of a representative PSF</li></ul><p><strong>Keywords:</strong></p><ul><li><code>thr</code>: threshold used to determine which pixels are bright enough to be &quot;hidden&quot;</li></ul><p><strong>Outputs:</strong></p><ul><li><code>flim</code>: maximum flux that can be masked by <code>thr</code> without exceeding the PSF stamp footprint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L39-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.kstar_circle_mask" href="#CloudCovErr.kstar_circle_mask"><code>CloudCovErr.kstar_circle_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kstar_circle_mask(Np;rlim=256) -&gt; circmask</code></pre><p>Generates a Bool mask for pixels beyond a given (squared) radius of the center of an image.</p><p><strong>Arguments:</strong></p><ul><li><code>Np</code>: size of image stamp</li></ul><p><strong>Keywords:</strong></p><ul><li><code>rlim</code>: squared radius (in pixels^2) beyond which pixels should be masked (default 256)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>circmask</code>: static Bool mask used for assigning pixels beyond some radius of the stellar center as &quot;ignored&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/preprocess.jl#L17-L30">source</a></section></article><h2 id="DECam-Specific-Functions"><a class="docs-heading-anchor" href="#DECam-Specific-Functions">DECam Specific Functions</a><a id="DECam-Specific-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#DECam-Specific-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.read_decam" href="#CloudCovErr.decam.read_decam"><code>CloudCovErr.decam.read_decam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_decam(base,date,filt,vers,ccd;corrects7=true) -&gt; ref_im, d_im</code></pre><p>Read in raw image files associated with exposures obtain on the DarkEnergyCamera. Returns the image and a quality flag mask image. See <a href="http://ast.noao.edu/sites/default/files/NOAO_DHB_v2.2.pdf">NOAO handbook</a> for more details on what is contained in each file and how they are obtained.</p><p><strong>Arguments:</strong></p><ul><li><code>base</code>: parent directory and file name prefix for exposure files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>ccd</code>: which ccd we are pulling the image for</li></ul><p><strong>Keywords:</strong></p><ul><li><code>corrects7</code>: use <code>crowdsource</code> load to read ccd &quot;S7&quot; to correct for floating amplifier on half of the chip (default true)</li></ul><p><strong>Output:</strong></p><ul><li><code>ref_im</code>: image of photoelectron counts from observation on DECam</li><li><code>d_im</code>: quality flag mask image from NOAO community pipeline</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ref_im, d_im = read_decam(&quot;/n/fink2/decaps/c4d_&quot;,&quot;170420_040428&quot;,&quot;g&quot;,&quot;v1&quot;,&quot;N14&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L79-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.read_crowdsource" href="#CloudCovErr.decam.read_crowdsource"><code>CloudCovErr.decam.read_crowdsource</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_crowdsource(basecat,date,filt,vers,ccd) -&gt; x_stars, y_stars, flux_stars, decapsid, gain, mod_im, sky_im, wcol, w</code></pre><p>Read in outputs of crowdsource, a photometric pipeline. To pair with an arbitrary photometric pipeline, an analogous read in function should be created. The relevant outputs are the model image (including the sources) so that we can produce the residual image, the sky/background model (no sources), and the coordinates of the stars. The survey id number is also readout of the pipeline solution file to help cross-validate matching of the CloudCovErr outputs and the original sources. The empirical gain is read out of the header (for other photometric pipelines which don&#39;t perform this estiamte, the gain from DECam is likely sufficient). All columns from the photometric catalogue are also read in at this point to be rexported with the CloudCovErr outputs.</p><p><strong>Arguments:</strong></p><ul><li><code>basecat</code>: parent directory of the cat directory holding all of the single-epoch crowdsource catalogue files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>ccd</code>: which ccd we are pulling the image for</li></ul><p><strong>Keywords:</strong></p><ul><li><code>corrects7</code>: use <code>crowdsource</code> load to read ccd &quot;S7&quot; to correct for floating amplifier on half of the chip (default true)</li></ul><p><strong>Output:</strong></p><ul><li><code>x_stars</code>: list of source x-coordinates (accounting for indexing order and start point)</li><li><code>y_stars</code>: list of source y-coordinates (accounting for indexing order and start point)</li><li><code>flux_stars</code>: list of stellar fluxes in ADU</li><li><code>decapsid</code>: list of survey id number for each detection</li><li><code>gain</code>: gain of detector to convert from photon count noise to detector noise</li><li><code>mod_im</code>: model image (including the sources) from photometric pipeline</li><li><code>sky_im</code>: sky image (background estimate) from photometric pipeline</li><li><code>wcol</code>: list of all column names in photometric catalogue</li><li><code>w</code>: list of all column values in photometric catalogue</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L135-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.inject_rename" href="#CloudCovErr.decam.inject_rename"><code>CloudCovErr.decam.inject_rename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inject_rename(fname) -&gt; ifname</code></pre><p>Convenience renaming file paths to read data from injection tests which are stored separately from data obtained on DECam for data provenance purposes.</p><p><strong>Arguments:</strong></p><ul><li><code>fname</code>: file name for exposure data from DECam</li></ul><p><strong>Output:</strong></p><ul><li><code>ifname</code>: corresponding file name for injection tests into that exposure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.load_psfmodel_cs" href="#CloudCovErr.decam.load_psfmodel_cs"><code>CloudCovErr.decam.load_psfmodel_cs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_psfmodel_cs(base,date,filt,vers,ccd) -&gt; psfmodel</code></pre><p>Julia wrapper function for the PyCall that reads the position dependent psfmodel produced by crowdsource from the catalogue file for a given exposure and ccd. The returned psfmodel takes an x- and y-position for the source location and the size of the desired psfstamp (the stamps are square and required to be odd).</p><p><strong>Arguments:</strong></p><ul><li><code>base</code>: parent directory and file name prefix for catalogue files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>ccd</code>: which ccd we are pulling the image for</li></ul><p><strong>Output:</strong></p><ul><li><code>psfmodel</code>: function that returns PSF stamp from parametric PSF model that is a function of position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L197-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.save_fxn" href="#CloudCovErr.decam.save_fxn"><code>CloudCovErr.decam.save_fxn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_fxn(wcol,w,basecat,date,filt,vers,ccd)</code></pre><p>Saves CloudCovErr.jl outputs and initial photometric catalogue outputs to a new single-epoch catalogue. Massages types of columns to reduce data storage size. Converts the native CloudCovErr.jl output of the bias offset value into a <code>cflux</code> corrected flux column for the ease of catalogue users.</p><p><strong>Arguments:</strong></p><ul><li><code>wcol</code>: list of all column names in photometric catalogue</li><li><code>w</code>: list of all column values in photometric catalogue</li><li><code>basecat</code>: parent directory of the cat directory holding all of the single-epoch crowdsource catalogue files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>ccd</code>: which ccd we are pulling the image for</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L224-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.get_catnames" href="#CloudCovErr.decam.get_catnames"><code>CloudCovErr.decam.get_catnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_catnames(f) -&gt; extnames</code></pre><p>Reads list of extension names from an open FITS file to determine which CCDs have completed photometric catalogues and are eligible for CloudCovErr.jl.</p><p><strong>Arguments:</strong></p><ul><li><code>f</code>: an open FITS file handle containing <code>crowdsource</code> catalogues</li></ul><p><strong>Outputs:</strong></p><ul><li><code>extnames</code>: list of CCDs that have photometric catalogues in f</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L263-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.proc_ccd" href="#CloudCovErr.decam.proc_ccd"><code>CloudCovErr.decam.proc_ccd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proc_ccd(base,date,filt,vers,basecat,ccd;thr=20,outthr=20000,Np=33,corrects7=true,widx=129,widy=widx,tilex=1,tiley=tilex,ftype::Int=32)</code></pre><p>Primary run function for a given CCD image of a larger exposure.</p><p><strong>Arguments:</strong></p><ul><li><code>base</code>: parent directory and file name prefix for exposure files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>basecat</code>: parent directory of the cat directory holding all of the single-epoch crowdsource catalogue files</li><li><code>ccd</code>: which ccd we are pulling the image for</li></ul><p><strong>Keywords:</strong></p><ul><li><code>thr</code>: threshold used for flux-dependent masking (default 20)</li><li><code>outthr</code>: threshold for residual-based masking (default 20000)</li><li><code>Np</code>: size of local covariance matrix in pixels (default 33)</li><li><code>corrects7</code>: use <code>crowdsource</code> load to read ccd &quot;S7&quot; to correct for floating amplifier on half of the chip (default true)</li><li><code>widx</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>widy</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>tilex</code>: total number of tile divisions along x (default 1)</li><li><code>tiley</code>: total number of tile divisions along y (default tilex)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L293-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudCovErr.decam.proc_all" href="#CloudCovErr.decam.proc_all"><code>CloudCovErr.decam.proc_all</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proc_all(base,date,filt,vers,basecat;ccdlist=String[],resume=false,corrects7=true,thr=20,outthr=20000,Np=33,widx=129,widy=widx,tilex=1,tiley=tilex,ftype::Int=32)</code></pre><p>Exposure level run function the manages which ccds to run and calls proc_ccd serially.</p><p><strong>Arguments:</strong></p><ul><li><code>base</code>: parent directory and file name prefix for exposure files</li><li><code>date</code>: date_time of the exposure</li><li><code>filt</code>: optical filter used to take the exposure</li><li><code>vers</code>: NOAO community processing version number</li><li><code>basecat</code>: parent directory of the cat directory holding all of the single-epoch crowdsource catalogue files</li></ul><p><strong>Keywords:</strong></p><ul><li><code>ccdlist</code>: run only ccds in this list</li><li><code>resume</code>: if the exposure is partially complete, resume running from where it left off (default false)</li><li><code>corrects7</code>: use <code>crowdsource</code> load to read ccd &quot;S7&quot; to correct for floating amplifier on half of the chip (default true)</li><li><code>thr</code>: threshold used for flux-dependent masking (default 20)</li><li><code>outthr</code>: threshold for residual-based masking (default 20000)</li><li><code>Np</code>: size of local covariance matrix in pixels (default 33)</li><li><code>widx</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>widy</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>tilex</code>: total number of tile divisions along x (default 1)</li><li><code>tiley</code>: total number of tile divisions along y (default tilex)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudCovErr.jl/blob/a873d13e18ffa4a0d884e695d22f79e622a3af05/src/decam.jl#L463-L487">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../contrib/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 21 June 2023 01:23">Wednesday 21 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
